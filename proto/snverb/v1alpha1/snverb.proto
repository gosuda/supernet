syntax = "proto3";

package snverb;

import "proto/maddr/v1alpha1/maddr.proto";

option go_package = "gosuda.org/supernet/proto/snverb/v1alpha1;snverb";

// SigningAlgorithm defines various cryptographic algorithms used for signatures, encryption, and hashing.
enum SignatureAlgorithm {
  // ED25519 is the Ed25519 digital signature algorithm.
  ED25519 = 0;
  // ED448 is the Ed448 digital signature algorithm.
  ED448 = 1;

  // ECDSA_NIST_P256 is the ECDSA with NIST P-256 curve.
  ECDSA_NIST_P256 = 2;
  // ECDSA_NIST_P384 is the ECDSA with NIST P-384 curve.
  ECDSA_NIST_P384 = 3;
  // ECDSA_NIST_P521 is the ECDSA with NIST P-521 curve.
  ECDSA_NIST_P521 = 4;

  // MLDSA44 is the ML-DSA-44 digital signature algorithm (NIST PQC).
  MLDSA44 = 5;
  // MLDSA65 is the ML-DSA-65 digital signature algorithm (NIST PQC).
  MLDSA65 = 6;
  // MLDSA87 is the ML-DSA-87 digital signature algorithm (NIST PQC).
  MLDSA87 = 7;
}

enum DigestAlgorithm {
  // SHA256 is the SHA-256 digest algorithm.
  SHA256 = 0;
  // SHA384 is the SHA-384 digest algorithm.
  SHA384 = 1;
  // SHA512 is the SHA-512 digest algorithm.
  SHA512 = 2;
  // SHA3_256 is the SHA3-256 digest algorithm.
  SHA3_256 = 3;
  // SHA3_384 is the SHA3-384 digest algorithm.
  SHA3_384 = 4;
  // SHA3_512 is the SHA3-512 digest algorithm.
  SHA3_512 = 5;
  // BLAKE2B is the BLAKE2b digest algorithm.
  BLAKE2B = 6;
  // BLAKE3 is the BLAKE3 digest algorithm.
  BLAKE3 = 7;
}

enum KeyExchangeAlgorithm {
  // X25519 is the X25519 elliptic curve Diffie-Hellman key exchange.
  X25519 = 0;
  // X448 is the X448 elliptic curve Diffie-Hellman key exchange.
  X448 = 1;

  // ECDH_NIST_P256 is the ECDH with NIST P-256 curve.
  ECDH_NIST_P256 = 2;
  // ECDH_NIST_P384 is the ECDH with NIST P-384 curve.
  ECDH_NIST_P384 = 3;
  // ECDH_NIST_P521 is the ECDH with NIST P-521 curve.
  ECDH_NIST_P521 = 4;

  // MLKEM512 is the ML-KEM-512 key encapsulation mechanism (NIST PQC).
  MLKEM512 = 5;
  // MLKEM768 is the ML-KEM-768 key encapsulation mechanism (NIST PQC).
  MLKEM768 = 6;
  // MLKEM1024 is the ML-KEM-1024 key encapsulation mechanism (NIST PQC).
  MLKEM1024 = 7;
}

enum EncryptionAlgorithm {
  // AES128_GCM is the Advanced Encryption Standard with 128-bit key in Galois/Counter Mode.
  AES128_GCM = 0;
  // AES256_GCM is the Advanced Encryption Standard with 256-bit key in Galois/Counter Mode.
  AES256_GCM = 1;
  // CHACHA20_POLY1305 is the ChaCha20-Poly1305 authenticated encryption algorithm.
  CHACHA20_POLY1305 = 2;
  // XCHACHA20_POLY1305 is the XChaCha20-Poly1305 authenticated encryption algorithm.
  XCHACHA20_POLY1305 = 3;
}

// IdentityKey represents a cryptographic public key with its unique identifier and the signature algorithm used.
message IdentityKey {
  uint64 key_id = 1; // 64-bit key id
  SignatureAlgorithm algorithm = 2;
  bytes public_key = 3;
}

// Signature contains the signature bytes along with the key ID, signature algorithm, and digest algorithm used for verification.
message Signature {
  uint64 key_id = 1; // 64-bit key id
  SignatureAlgorithm algorithm = 2;
  DigestAlgorithm digest_algorithm = 3;
  bytes signature = 4;
}

message MultiSignature {
  repeated Signature signatures = 1;
}

// Identity encapsulates a collection of public keys associated with an entity for authentication and verification purposes.
message Identity {
  repeated IdentityKey public_keys = 1;
}

// RouterClass enumerates the types of router nodes in the network, indicating their level of functionality and resource requirements.
enum RouterClass {
  FULL_NODE = 0; // Full-featured router with complete networking capabilities.
  MINI_NODE = 1; // Lightweight router with reduced functionality for smaller scale use.
  NANO_NODE = 2; // Minimal router optimized for ultra-low resource environments.
}

// RouterFeature lists the optional features that a router can support, influencing its role and capabilities in the network.
enum RouterFeature {
  EXCHANGE = 0; // Supports key exchange operations for secure communication establishment.
  LEASE = 1; // Provides address leasing services for dynamic network allocation.
  RELAY = 2; // Acts as a relay for forwarding packets through the network.
}

// RouterInfo provides metadata about a router node, including its identity, network addresses, classification, and supported features.
message RouterInfo {
  bytes router_id = 1; // 128-bit router id
  Identity identity = 2; // Identity containing the public keys for this router.
  int64 version = 3; // Version number of the router information for compatibility checking.
  int64 timestamp = 4; // Timestamp of the router information.
  maddr.AddressList address_list = 5; // List of network addresses where this router can be reached.
  RouterClass router_class = 6; // Classification of the router determining its capabilities.
  repeated RouterFeature features = 7; // List of features supported by this router node.
}

// SignedRouterInfo is a RouterInfo message signed by the router's identity.
message SignedRouterInfo {
  bytes router_info = 1; // RouterInfo message serialized to bytes.
  MultiSignature signature = 2; // MultiSignature of the RouterInfo message. (policy: any)
}

// VirtualAddress represents a virtual address in the network.
message VirtualAddress {
  Identity identity = 1; // Identity of the virtual address
}

// Dropzone is a logical home for a virtual address.
message Dropzone {
  bytes router_id = 1; // 128-bit router id
  bytes tunnel_id = 2; // 128-bit tunnel id
}

// DropzoneSet is a set of dropzones for a virtual address.
message DropzoneSet {
  bytes virtual_address = 1; // 128-bit virtual address id
  int64 timestamp = 2; // Timestamp of the dropzone set
  repeated Dropzone dropzones = 3; // List of dropzones for the virtual address
}

// SignedDropzoneSet is a DropzoneSet message signed by the router's identity.
message SignedDropzoneSet {
  bytes dropzone_set = 1; // DropzoneSet message serialized to bytes.
  MultiSignature signature = 2; // MultiSignature of the DropzoneSet message. (policy: any)
}

// TunnelDescriptor represents a tunnel between two endpoints, including the tunnel ID, destination, and source.
message TunnelDescriptor {
  bytes tunnel_id = 1; // 128-bit tunnel id
  bytes destination = 2; // 128-bit destination id
  bytes source = 3; // 128-bit source id
}
